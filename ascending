#include <stdio.h>
#include <stdlib.h>



//swap의 원리는 매개변수를 포인터로 줌으로써 , 실제 *a =10을 가르키지만 , 주소를 통해서 얻은 값이다. 그러므로 , 변경을 할 떄도 , reallocating 할 떄 , 바꾸더라도 ,성공한느 것이다.
//반면 call by value는 복사된 것을 전달해줄 뿐이다.

void swap(int* a, int* b) {
	int temp = *a;
	*a = *b;
	*b = temp;
}


void Ascending(int arr[], int n) {

	int i = 0;
	int counter;
	int solution = 0;
	for(counter=0; counter<n-2 ;counter++) {

		int	*min = &arr[counter];
		// 시발 내가 왜 이걸 기억 못했지 , i문을 다시 시작하면 i는 다시 0으로 되잖아 ㅁㄹㄴㅇㄹ ㅁㄴㅇㄹ ㅁㄴㅇㄻ ㄴㅇㄻㄴㅇㄻㄴㅇㄻㄴㅇㄻㄴㅇㄻㄴㅇㄹ 안의 loop가 끝나고 바깥 루프를 실행한 이후에.

		while (i < n - 2) {

			if (*min > arr[i + 1])
			{
				min = &arr[i + 1];
			}
			i++;
		}
	

			swap(min,&arr[counter]); 
			i = ++solution;

	}
}

int main() {

	int arr[7] = { 6,4,3,2,1,3,8 };
	Ascending(arr, 7);

	for (int i = 0; i < 7; i++) {

		printf("%3d", arr[i]);
	}

}
