#include <stdio.h>
#include <stdlib.h>

//도수분포표의 특징은 안정적인 정렬이라는 것이다 하지만 입력 변수의 최대값과 최솟값을 알고있어야 한가
//단일 for문만을 이용해서 비교적 빠른 정렬속도를 보여준다.
//다만 3번 작업에서 b배열에 옮기는 과정에서 i=0값으로 주고 시작한다면 , 누적도수 분포표의 값이 변하므로 순서가 반대로 넣어질 수가 있다 .동일 3,3이 있다고 가정하면 뒤에있는 3이 정렬할 때는 앞으로 갈 수있다는 것이다 (누적도수분포표에 의해서) -> --f[a[i]
//ex 내가 작성한 배열 중 3은 두 개가있다 . 3번을 0부터 시작해서 한다고하면 , b[--f[a[6]] 일 때 앞에있는 3이 b[4]에 들어가게 되고 -1만큼 감소하여 누적분포표의 수를 4로 감소시킨다. 따라서 뒤에있는 3은 앞으로 오게되는 것이다. (순서가 바뀜)

void fsort(int a[], int n, int max) {
//max는 작업용 배열에서 가장 큰 값.
//배열 b는 임시배열
//배열 f는 작업용 배열.
	int i;
	int* f = calloc(max + 1, sizeof(int));
	int* b = calloc(n , sizeof(int));


	//1.배열 초기화
	//2.도수분포표 작성
	//3.누적도수분포표
	//4.b에 배열 입력
	//5.실제 배열에 옮기기

	for (i = 0; i <= max; i++) f[i] = 0;
	for (i = 0; i < n; i++) f[a[i]]++; // 그림 보면서 이해를 하면 돼 ,0으로 초기화를 했으니까 후위연산자로 1씩 늘려주면 돼
	//실수한 부분이다 .근데 답을 바로 봐버렸다 .큰 실수다. 작업용 배열이니 max를 사용 했었어야했다.//for (i = 1; i <= max; i++) f[i] += f[i-1]; //0을 박을 필요가없지 . a[-1]은 초기화도 되어있지 않으니까. 이 부분도 틀렸다 f[i]는 작업용 배열이므로 max를 활용해야한다.
	for (i = n-1; i >= 0; i--) 	b[--f[a[i]]] = a[i]; // 복사배열에 a[i] 값을 넣어야한다. 이때 누적도수분포표의 값이 변화한다. --f[a[i]] 이므로 f[a[i]] 값은 1 감소하게 되고 b배열에 한 칸 당겨져서 입력된다.
	for (i = 0; i < n; i++) a[i] = b[i];
	






}



int main() {

	int i;
	int a[9] = { 5,7,0,2,4,10,3,1,3};

	fsort(a, 9, 10);

	for (i = 0; i < 9; i++) {

		printf("%4d", a[i]);
	}
}
